#ifndef __MISC_H__
#define __MISC_H__

#include "stdint.h"

#undef NULL
#define NULL 0

typedef unsigned long bool;

#define true	1
#define false	0

#define M_PI		        3.14159265358979323846f
#define DEGREE(radian)  180.0f*(radian)/M_PI
#define RADIAN(degree)  M_PI*(degree)/180.0f

#define MAX(a,b) (a)>(b) ? (a) : (b)
#define MIN(a,b) (a)<(b) ? (a) : (b)

#define INRANGE(v,min,max) (((v)>=(min)) && ((v)<=(max)))
#define RANGE(v,min,max) if(v<min) v=min; if(v>max) v=max

#define uInt16ToBigEndian(U16) (uint16_t) ( (uint16_t)(U16<<8) | (uint16_t)(U16>>8) )
#define uInt16FromBigEndian(U16) uInt16ToBigEndian(U16)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* ПРИ ИСПОЛЬЗОВАНИИ ФУНКЦИЙ utoa() stoa() utoa_hex() ОБЯЗАТЕЛЬНО ВЫДЕЛЯТЬ БУФЕР buffer[...] РАЗМЕРОМ НЕ МЕНЬШЕ ТОГО, КОТОРЫЙ УКАЗАН В [] СКОБКАХ СООТВЕТСТВУЮЩЕЙ ФУНКЦИИ */
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
конвертирует значение целое value в строку,
 buffer-масив символов для хранения строки размером 11 байт
 prev- символ перед числом если ширина строки < width, например 0 или пробел
 width- количество символов в строке, если 0 то число преобразуется со своей шириной
 Примеры: 
         utoa(1234,buff,'0',5)->01234
         utoa(1234,buff,' ',6)->  1234
*/
char* utoa(uint64_t value, char buffer[21], char prev, uint8_t width);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*тоже что и utoa, но со знаком плюс или минус знак выводяться всегда
количество символов числа (width) задается без учета знака
 Примеры: 
          stoa(1234,buff,'0',5)->+01234
          stoa(1234,buff,' ',6)->+  1234
          stoa(1234,buff,' ',4)->+1234

*/
char*stoa(int64_t value, char buffer[21], char prev, uint8_t width);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* копирует count символов строки str2 в str1, добавляет в конец str1
нулевой символ. Не боиться если память str1 и str2 перекрывается, также
не имеет значение если str1 и str2 не заканчиваются нулевым символом
*/
char* strnset(char* str1, char* str2, unsigned int count);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
конвертирует число i (0..15) в соответствующий HEX символ (0..F)
*/
char DecToHex(uint8_t i);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
конвертирует HEX символ (0..F) в число i (0..15)
*/
uint8_t HexToDec(char ch);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
конвертирует значение целое value в строку HEX символов,
*/
char* utoa_hex(uint64_t value, char buffer[17], char prev, uint8_t width);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
 конвертирует значение double n в строку,
 buffer-масив символов для хранения строки, если число отрицательное то перед ним
 выводиться знак минус, width-опредяляет размер строки в символах, с учетом
 знака (если он есть) и разделителя (.), если число не может поместиться в width, то оно
 займет необходимое количество символов. prec определяет сколько знаков после запятой 
 отображать, число округляется до этой точности 
 примеры:
          double d=1234.56789
          dtoa(d,buff,8,2)->01234.57
          dtoa(-d,buff,8,2)->-1234.57
          dtoa(d,buff,0,0)->1235
          dtoa(d,buff,7,0)->0001235


*/
char* dtoa(double n, char *buf, uint8_t width, uint8_t prec);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* складывает знаковые целые числа с обработкой ошибки переполнения */ 
int summ(int a, int b, bool *overflow);

uint32_t power(uint32_t x, uint32_t y);

#endif

